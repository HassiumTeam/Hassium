use Crypto;
use Drawing;
use IO;
use Math;
use Net;
use Text;
use Types;
use Util;

from IO use FS;
from IO use Path;

from FuncDoc use FuncDoc;

func main () {
	docmodule (Crypto, "Crypto");
	docmodule (Drawing, "Drawing");
	docmodule (IO, "IO");
	docmodule (Math, "Math");
	docmodule (Net, "Net");
	docmodule (Text, "Text");
	docmodule (Types, "Types");
	docmodule (Util, "Util");
}

func docmodule (mod : object, name : string) {
	if (!FS.direxists (name)) {
		FS.createdir (name);
	}

	FS.cwd = Path.combine (FS.cwd, name); 

	classes = getattribs (mod);

	foreach (clazz in classes) {
		docclazz (clazz [1], clazz [0]);
	}

	FS.cwd = Path.combine (FS.cwd, "../");
}

func docclazz (clazz, name : string) {
	file = FS.open ("{0}.md".format (name));

	file.writeline ("## class {0}\n".format (name));

	attribs = getattribs (clazz);

	foreach (attrib in attribs) {
		funcdoc = new FuncDoc (attrib [1]);
		foreach (rep in funcdoc.sourcereps) {
			file.writeline ("#### ```{0}```\n\n".format (rep));
			file.writeline ("```@desc:``` {0}\n".format (funcdoc.desc));
			foreach (param in funcdoc.reqparams) {
				file.writeline ("\t```@param {0}:``` {1}".format (param [0], param [1]));
			}
			foreach (param in funcdoc.optparams) {
				file.writeline ("\t```@optional {0}:``` {1}".format (param [0], param [1]));
			}
			file.writeline ("```@returns:``` {0}\n".format (funcdoc.returns));
		}
	}

	file.close ();
}

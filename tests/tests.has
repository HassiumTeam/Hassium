# Welcome to HATRED.
# Hassium Testing Runtime Environment Distribution
use Math;
use io;
use drawing;
use debug;

exitcode = 0;
failed = 0;
passed = 0;


class TestClass {
    func testFunc(num1, num2) {
        return num1 + num2;
    }
}

func assert(that, msg)
{
	println(msg + " [" + (that ? "✓" : "✗") + "]");
	
	if(that)
	{
		passed++;
	}
	else
	{
		failed++;
		exitcode = 1;
	}
}

func assertfail(that, msg)
{
	isfailed = false;
	try 
	{
		eval(that);
	}
	catch
	{
		isfailed = true;
	}
	theMsg = msg + " [" + (isfailed ? "✓" : "✗") + "]";
	if(isfailed)
	{
		passed++;
	}
	else
	{
		failed++;
		exitcode = 1;
	}
	println(theMsg);
}
func main()
{
    println("--- BEGIN TESTS FOR HASSIUM " + Interpreter.version + " ---");

    opTests();
    numberFormatTests();
    functionTests();
    closureTest();
    objectTest();
    recursionTest();
    instanceTest();
	importTests();
	eventTests();
	arrayTests();
	drawingTests();
    println();
    if(failed == 0) println("Everything went good");
    else println("Some tests failed.");
    println();
    println(passed + " test" + (passed == 1 ?: "s") + " passed");
    println(failed + " test" + (failed == 1 ?: "s") + " failed");
    println("--- END TESTS FOR HASSIUM ---");
	println();
	println("Current version: Hassium ", Interpreter.version);
	println("Build date: " + Interpreter.buildDate.toString("x"));
	

    exit(exitcode);
	
	println("This should not be seen, as there's an exit() line above.");
}

func opTests()
{
    println("Operators tests");
    println();

    # basic operators
    assert(13 + 8 == 21, "should pass if addition result is correct");
    assert(29 - 56 == -27, "should pass if substraction result is correct");
    assert(36 / 3 == 12, "should pass if division result is correct");
    assertfail("38 / 0 == 1", "should fail (division by zero)");
    assert(41 * 3 == 123, "should pass if multiplication result is correct");
    assert(117 % 17 == 15, "should pass if modulo result is correct");

	# equals
	assert(5 == 5, "int should be equal to itself");
	assert(3.14 == Math.round(Math.pi, 2), "int should be equal to itself");
	assert("abc" == "abc", "string should be equal to itself");
	assert(["abc", 123, 4.81654] == [4.81654, 123, "abc"].reverse(), "array should be equal to itself");
	assert(["abc": 123, 456: "def", "ghi": 789] == ["ghi": 789, 456: "def", "abc": 123].reverse(), "dictionary should be equal to itself");
	assert(true == !false, "true should be equal to !false");
	assert(date(1,2,3,4,5,6) == date(1,2,3,4,5,6), "date should be equal to itself");
	
    # comparison
    assert(14 < 21, "object should be less than value");
    assert(38 > -8, "object should be greater than value");
    assert(1 != 2, "object should not be equal to value");
    assert(38 <= 41 - 3, "object should be less or equal than value");
    assert (21 >= 14 + 7, "object should be greater or equal than value");

    # logical
    assert(2 + 2 == 4 && 3 + 3 == 6, "should pass if both values are true");
    assert(8 * 3 == 1515 || 3 * 9 == 27, "should pass if any of the values is true");

    # bitwise
    assert(5 ^ 3 == 6, "should pass if XOR result is correct");
    assert(23 << 2 == 92, "should pass if Bitshift Left result is correct");
    assert(-105 >> 1 == -53, "should pass if Bitshift right result is correct");
    assert(6 & 13 == 4, "should pass if AND result is correct");
    assert(5 | 3 == 7, "should pass if OR result is correct");

    # other
    assert(12 ** 3 == 1728, "should pass if ** (power) result is correct");
    assert(512 // 3 == 8, "should pass if // (root) result is correct");
	
	# ++ and --
	abc = 5;
	assert(abc++ == 5, "post-fix should increment after returning");
	assert(++abc == 7, "pre-fix should increment before returning");
	assert(abc-- == 7, "post-fix should decrement after returning");
	assert(--abc == 5, "pre-fix should increment before returning");
	
	# operator precedence
	assert(8 * 2 ** 3 - 4 * 4 / 8.0 == 62, "operator precedence 1");
	assert(4 * 4 / 8.0 == 2, "operator precedence 2");
	
	assert(0b1111_1111_1111_1111 == 0xFFFF, "binary / hex / digit separator");

    ab = null;
    cd = 5;
    assert((ab ?? cd) == 5, "should pass if ?? (null-coalescing) result is correct");

    assert(1 <=> 2 == -1, "should pass if <=> result is correct");
	
	boolean = true;
	assert((boolean ? "ab" : "cd") == "ab", "should pass if ?: (ternary operator) result is correct");
	assert((boolean ? "cd") == "cd", "should pass if ? (ternary operator) result is correct");


    println();
    println("End of operator tests");
    println();
}

func functionTests()
{
    func test(x) {
        return x * 4;
    }

    println("Functions tests");
    println();
    assert(test(4) == 16, "should pass if Function test(4) is correct");
    println();
    assert(TestClass.testFunc(4, 5) == 9, "should pass if Function TestClass.testFunc(4, 5) is correct");
    println("End of function tests");
    println();
}

func numberFormatTests()
{
    println("Number format tests");
    println();
    assert(0xDA == 218, "should pass if hexadecimal numbers are parsed correctly");
    assert(0o173 == 123, "should pass if octal numbers are parsed correctly");
    assert(0b110101011 == 427, "should pass if binary numbers are parsed correctly");
    assert(Math.round(runtimecall("System.Math.PI"), 2) == 3.14, "should pass if decimal numbers are parsed correctly");
    println();
    println("End of number format tests");
    println();
}



func closureTest() {
    println("Closures tests");
    println();
    func startAt (x) {
        return lambda (y) {
            return x + y;
        }
    }
    closure1 = startAt (1);
    closure2 = startAt (5);
    a = closure1(3);
    b = closure2(3);
    assert(a == 4, "closure1(3) should equal 4");
    assert(b == 8, "closure2(3) should equal 8");
    println();
    println("End of closures tests");
    println();
}

    func recursion (c) {
        if (c == 5) {
            assert(c == 5, "c be 5");
            recursion (c + 1);
            assert(c == 5, "c should remain 5");
            recursion (c + 1);
            assert(c == 5, "c should still remain 5");
            }
        return 0;
    }
    
    func fib (n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        return fib (n - 1) + fib (n - 2);
    }

func recursionTest()
{
    println("Recursion tests");
    println();
    recursion(5);
    assert(fib(6) == 8, "fib(6) should equals 8");
    println();
    println("End of recursion tests");
    println();
}

func objectTest () {
    println("Prototyping tests");
    println();
    
    func Person (name, age)
    {
        ret = new Object();
        ret.getName = this => this.name;
        ret.getAge = this => this.age;
        ret.toString = this => "Hello my name is " + this.name + " and I'm " + age + " years old.";
        ret.name = name;
        ret.age = age;
        return ret;
    }
    
    person = Person ("Reagan", 16);
    assert (person.name == "Reagan", "person.name should equal Reagan");
    assert (person.age == 16, "person.age should equal 16");
    assert (person.getName () == "Reagan", "person.getName () should equal Reagan");
    assert (person.getAge () == 16, "person.getAge () should equal 16");
    assert (person.toString() == "Hello my name is Reagan and I'm 16 years old.", "person.toString()");
    
    println();
    println("End of prototyping tests");
    println();
}
    
class PersonClass
{
    func new(name, age)
    {
        this.Name = name;
        this.Age = age;
    }
	
	
    
    property Name
	{
		get;
		set;
	}
	
	property Age
	{
		get;
		set;
	}
    
    func toString(this)
    {
        return "Hello my name is " + this.Name + " and I'm " + this.Age + " years old.";
    }
}

class Employee : PersonClass
{
	func new(name, age, location) : base(name, age)
	{
		this.Location = location;
	}
	
	property Location
	{
		get;
		set;
	}
	
	func toString(this)
	{
		return "Hello my name is " + this.Name + " and I'm " + this.Age + " years old and I live in " + this.Location + ".";
	}
}
    
func instanceTest () {
    println("Class instance tests");
    println();

    person = new PersonClass ("Reagan", 16);
    assert (person.Name == "Reagan", "person.name should equal Reagan");
    assert (person.Age == 16, "person.age should equal 16");
	person.Name = "New Reagan";
	person.Age = 34;
	assert (person.Name == "New Reagan", "person.name should equal New Reagan");
    assert (person.Age == 34, "person.age should equal 34");
    assert(person.toString() == "Hello my name is New Reagan and I'm 34 years old.", "person.toString()");
	employee = new Employee("Mark", 38, "New York");
	assert(employee.Name == "Mark", "employee.Name");
	assert(employee.Age == 38, "employee.Age");
	assert(employee.Location == "New York", "employee.Location");
	employee.Location = "Paris";
	assert(employee.Location == "Paris", "employee.Location after setting property");
	assert(employee.toString() == "Hello my name is Mark and I'm 38 years old and I live in Paris.", "employee.toString()");
    
    println();
    println("End of class instance tests");
    println();
}





func importTests()
{
	println("Module import tests");
    println();
	println("Importing testImport.has as myModule");
	use "testImport.has" as myModule;
	println("↓ this should print Hello from testImport.has!");
	myModule.printTest();
	assert(myModule.importVar == 5, "myModule.importVar should equal 5");
	println();
	println("Trying to instanciate myModule.importClass");
	myClass = new myModule.importClass("test");
	assert(myClass.getName() == "test", "myClass.getName() should equal test");
	println();
	println("Importing testImport.has in global scope");
	use "testImport.has";
	println("↓ this should print Hello from testImport.has!");
	printTest();
	assert(importVar == 5, "importVar should equal 5");
	
	
	
	println();
    println("End of module import tests");
    println();
}

func eventTests()
{
	println("Event tests");
    println();

	func handler1(args)
	{
		println("handler 1: " + args[0] + " " + args[1]);
	}
	
	func handler2(args)
	{
		println("handler 2: " + args[0] + " " + args[1]);
	}
	
	func handler3(args)
	{
		println("handler 3: " + args[0] + " " + args[1]);
	}
	
	func handler4(args)
	{
		println("handler 4: " + args[0] + " " + args[1]);
	}
	hand = new Event(handler1, handler2);
	
	hand += handler3;
	hand += handler4;
	
	hand("abc");
	
	hand -= handler1;
	hand -= handler2;
	hand -= handler3;
	
	hand("abc");
	
	println();
    println("End of event tests");
    println();
}

func arrayTests()
{
	println("Array tests");
	println();
	
	theStr = "abcdef";
	theStrArr = [];
	foreach(c in theStr)
	{
		theStrArr[] = c;
	}
	assert(theStrArr == ["a","b","c","d","e","f"], "string to char array");
	
	theArr = ["abc", "def", 123, 456, runtimecall("System.Math.PI")];	
	assert(theArr.toString() == "Array { abc, def, 123, 456, 3.14159265358979 }", "array to string");
	theArr2 = [];
	foreach(x in theArr)
	{
		theArr2[] = x;
	}	
	assert(theArr[1 : 3] == ["def", 123, 456], "array slice");
	assert(theArr2.toString() == "Array { abc, def, 123, 456, 3.14159265358979 }", "array to string after foreach");

	theDict = ["abc" : 123, 456 : "ghi", "jkl" : 789];
	theDict[123] = "mno";
	theDict[] = 456; # if you use the [] operator with nothing inside, it appends at the end of the array
	assert(theDict[123] == "mno", "check dictionary value after setting with []");
	assert(theDict.toString() == "Dictionary { [abc] => 123, [456] => ghi, [jkl] => 789, [123] => mno, [4] => 456 }", "dictionary to string");
	
	assert(theDict.all((key, value) => theDict[key] == value), "check key and value in dictionary");
	
	foreach([key, value] in theDict) # by using the tuple syntax you can foreach the keys and values
	{
		assert(theDict[key] == value, "check key and value, foreach in a dictionary");
	}
	
	println();
	println("End of array tests");
	println();
}

func drawingTests()
{
	println("Drawing module tests");
	println();
	
	clr = new Color("#f0f8ff");
	assert(clr.argb == -984833, "hex to color conversion, argb property check");
	
	clr = new Color("#2be1ce");
	assert(clr.red == 43, "color.red");
	assert(clr.green == 225, "color.green");
	assert(clr.blue == 206, "color.blue");
	
	assert(clr.complementary == new Color(225, 43, 62), "complementary color");
	assert(clr.complementary.complementary == clr, "complementary color back");
	
	assert(clr.triadic == [new Color(225, 206, 43), new Color(206, 43, 225)], "triadic color");
	assert(clr.tetradic == [new Color(62, 225, 43), new Color(206, 43, 225), new Color(225, 43, 62)], "tetradic color");
	assert(clr.splitCompl == [new Color(225, 115, 43), new Color(206, 43, 153)], "split complementary color");
	assert(clr.analogous == [new Color(43, 225, 115), new Color(43, 153, 225)], "analogous color");
	
	assert(clr.toHsl().values.select(x => Math.round(x, 1)) == [173.7, 75.2, 52.5], "color to HSL conversion");
	assert(clr.toHsv().values.select(x => Math.round(x, 1)) == [173.7, 80.9, 88.2], "color to HSV conversion");
	assert(clr.toCmyk().values.select(x => Math.round(x, 2)) == [80.89, 0, 8.44, 11.76], "color to CMYK conversion");
	assert(clr.toCmy().values.select(x => Math.round(x, 2)) == [83.14, 11.76, 19.22], "color to CMY conversion");
	assert(clr.toXyz().values.select(x => Math.round(x, 2)) == [39.06, 58.82, 67.69], "color to XYZ conversion");
	assert(clr.toLab().values.select(x => Math.round(x, 2)) == [81.19, -47.19, -3.12], "color to CIE-LAB conversion");
	assert(clr.toLch().values.select(x => Math.round(x, 2)) == [81.19, 47.29, 183.78], "color to CIE-LCH conversion");
	assert(clr.toLuv().values.select(x => Math.round(x, 2)) == [81.19, -62.15, 2.6], "color to CIE-LUV conversion");
	assert(clr.toHunterLab().values.select(x => Math.round(x, 2)) == [76.69, -43.30, 1.36], "color to Hunter-Lab conversion");
	assert(clr.toYuv().values.select(x => Math.round(x, 2)) == [168, 149, 38], "color to YUV conversion");
	
	clr = new Color("hsl", 173.7, 75.2, 52.5);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from HSL");
	
	clr = new Color("hsv", 173.7, 80.9, 88.2);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from HSV");
	
	clr = new Color("cmyk", 80.89, 0, 8.44, 11.76);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from CMYK");
	
	clr = new Color("cmy", 83.14, 11.76, 19.22);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from CMY");
	
	clr = new Color("xyz", 39.06, 58.82, 67.69);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from XYZ");
	
	clr = new Color("lab", 81.19, -47.19, -3.12);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from CIE-LAB");
	
	clr = new Color("lch", 81.19, 47.294403, 183.780079);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from CIE-LCH");
	
	clr = new Color("luv", 81.19, -62.15, 2.6);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from CIE-LUV");
	
	clr = new Color("hunter-lab", 76.69, -43.30, 1.36);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from Hunter-Lab");
	
	$clr = new Color("yuv", 168, 149, 38);
	assert(clr.red == 43 && clr.green == 225 && clr.blue == 206, "color after converting from YUV");$
	
	println();
	println("End of drawing module tests");
	println();
}

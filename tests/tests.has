# Welcome to HATRED.
# Hassium Testing Runtime Environment Distribution
use Math;
use io;

exitcode = 0;
failed = 0;
passed = 0;

class TestClass {
    func testFunc(num1, num2) {
        return num1 + num2;
    }
}

func assert(that, msg)
{
	println(msg + " [" + (that ? "✓" : "✗") + "]");
	
	if(that)
	{
		passed++;
	}
	else
	{
		failed++;
		exitcode = 1;
	}
}

func assertfail(that, msg)
{
	isfailed = false;
	try 
	{
		eval(that);
	}
	catch
	{
		isfailed = true;
	}
	theMsg = msg + " [" + (isfailed ? "✓" : "✗") + "]";
	if(isfailed)
	{
		passed++;
	}
	else
	{
		failed++;
		exitcode = 1;
	}
	println(theMsg);
}

class ConsoleCursor
{
	property Left
	{
		get
		{
			return console.cursorPos.left;
		}
		set
		{
			console.cursorPos.left = value;
		}
	}
}

func main()
{
	ConsoleCursor.Left = 5;
	println(console.cursorPos);

    println("--- BEGIN TESTS FOR HASSIUM ---");
    
    opTests();
    numberFormatTests();
    functionTests();
    closureTest();
    objectTest ();
    recursionTest(5);
    instanceTest();
	importTests();
	eventTests();
	arrayTests();
    println();
    if(failed == 0) println("Everything went good");
    else println("Some tests failed.");
    println();
    println(passed + " tests passed");
    println(failed + " tests failed");
    println("--- END TESTS FOR HASSIUM ---");
    
	
	
    exit(exitcode);
}

func opTests()
{
    println("Operators tests");
    println();

    # basic operators
    assert(13 + 8 == 21, "should pass if addition result is correct");
    assert(29 - 56 == -27, "should pass if substraction result is correct");
    assert(36 / 3 == 12, "should pass if division result is correct");
    assertfail("38 / 0 == 1", "should fail (division by zero)");
    assert(41 * 3 == 123, "should pass if multiplication result is correct");
    assert(117 % 17 == 15, "should pass if modulo result is correct");

    # comparison
    assert(5 == 5, "object should be equals to itself");
    assert(14 < 21, "object should be less than value");
    assert(38 > -8, "object should be greater than value");
    assert(1 != 2, "object should not be equal to value");
    assert(38 <= 41 - 3, "object should be less or equal than value");
    assert (21 >= 14 + 7, "object should be greater or equal than value");

    # logical
    assert(2 + 2 == 4 && 3 + 3 == 6, "should pass if both values are true");
    assert(8 * 3 == 1515 || 3 * 9 == 27, "should pass if any of the values is true");

    # bitwise
    assert(5 ^ 3 == 6, "should pass if XOR result is correct");
    assert(23 << 2 == 92, "should pass if Bitshift Left result is correct");
    assert(-105 >> 1 == -53, "should pass if Bitshift right result is correct");
    assert(6 & 13 == 4, "should pass if AND result is correct");
    assert(5 | 3 == 7, "should pass if OR result is correct");

    # other
    assert(12 ** 3 == 1728, "should pass if ** (power) result is correct");
    assert(512 // 3 == 8, "should pass if // (root) result is correct");

    ab = null;
    cd = 5;
    assert((ab ?? cd) == 5, "should pass if ?? (null-coalescing) result is correct");

    assert(1 <=> 2 == -1, "should pass if <=> result is correct");


    println();
    println("End of operator tests");
    println();
}

func functionTests()
{
    func test(x) {
        return x * 4;
    }

    println("Functions tests");
    println();
    assert(test(4) == 16, "should pass if Function test(4) is correct");
    println();
    assert(TestClass.testFunc(4, 5) == 9, "should pass if Function TestClass.testFunc(4, 5) is correct");
    println("End of function tests");
    println();
}

func numberFormatTests()
{
    println("Number format tests");
    println();
    assert(0xDA == 218, "should pass if hexadecimal numbers are parsed correctly");
    assert(0o173 == 123, "should pass if octal numbers are parsed correctly");
    assert(0b110101011 == 427, "should pass if binary numbers are parsed correctly");
    assert(Math.round(runtimecall("System.Math.PI"), 2) == 3.14, "should pass if decimal numbers are parsed correctly");
    println();
    println("End of number format tests");
    println();
}



func closureTest() {
    println("Closures tests");
    println();
    func startAt (x) {
        return lambda (y) {
            return x + y;
        }
    }
    closure1 = startAt (1);
    closure2 = startAt (5);
    a = closure1(3);
    b = closure2(3);
    assert(a == 4, "closure1(3) should equal 4");
    assert(b == 8, "closure2(3) should equal 8");
    println();
    println("End of closures tests");
    println();
}

    func recursion (c) {
        if (c == 5) {
            assert(c == 5, "c be 5");
            recursion (c + 1);
            assert(c == 5, "c should remain 5");
            recursion (c + 1);
            assert(c == 5, "c should still remain 5");
            }
        return 0;
    }
    
    func fib (n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        return fib (n - 1) + fib (n - 2);
    }

func recursionTest()
{

    


    println("Recursion tests");
    println();
    recursion(5);
    assert(fib(6) == 8, "fib(6) should equals 8");
    println();
    println("End of recursion tests");
    println();
}

func objectTest () {
    println("Prototyping tests");
    println();
    
    func Person (name, age)
    {
        ret = new Object();
        ret.getName = this => this.name;
        ret.getAge = this => this.age;
        ret.toString = this => "Hello my name is " + this.name + " and I'm " + age + " years old.";
        ret.name = name;
        ret.age = age;
        return ret;
    }
    
    person = Person ("Reagan", 16);
    assert (person.name == "Reagan", "person.name should equal Reagan");
    assert (person.age == 16, "person.age should equal 16");
    assert (person.getName () == "Reagan", "person.getName () should equal Reagan");
    assert (person.getAge () == 16, "person.getAge () should equal 16");
    assert(person.toString() == "Hello my name is Reagan and I'm 16 years old.", "person.toString()");
    
    println();
    println("End of prototyping tests");
    println();
}
    
    class PersonClass
    {
        func new(name, age)
        {
            this._name = name;
            this._age = age;
        }
		
		
        
        property Name
		{
			get { return this._name; }
			set { this._name = value; }
		}
		
		#property Age => this._age;
		
		property Age
		{
			get { return this._age; }
			set { this._age = value; }
		}
        
        func toString(this)
        {
            return "Hello my name is " + this.Name + " and I'm " + this.Age + " years old.";
        }
    }
    
func instanceTest () {
    println("Class instance tests");
    println();

    person = new PersonClass ("Reagan", 16);
    assert (person.Name == "Reagan", "person.name should equal Reagan");
    assert (person.Age == 16, "person.age should equal 16");
	person.Name = "New Reagan";
	person.Age = 34;
	assert (person.Name == "New Reagan", "person.name should equal New Reagan");
    assert (person.Age == 34, "person.age should equal 34");
    assert(person.toString() == "Hello my name is New Reagan and I'm 34 years old.", "person.toString()");
    
    println();
    println("End of class instance tests");
    println();
}





func importTests()
{
	println("Module import tests");
    println();
	println("Importing testImport.has as myModule");
	use "testImport.has" as myModule;
	println("↓ this should print Hello from testImport.has!");
	myModule.printTest();
	assert(myModule.importVar == 5, "myModule.importVar should equal 5");
	println();
	println("Trying to instanciate myModule.importClass");
	myClass = new myModule.importClass("test");
	assert(myClass.getName() == "test", "myClass.getName() should equal test");
	println();
	println("Importing testImport.has in global scope");
	use "testImport.has";
	println("↓ this should print Hello from testImport.has!");
	printTest();
	assert(importVar == 5, "importVar should equal 5");
	
	
	
	println();
    println("End of module import tests");
    println();
}

func eventTests()
{
	println("Event tests");
    println();

	func handler1(args)
	{
		println("handler 1: " + args[0] + " " + args[1]);
	}
	
	func handler2(args)
	{
		println("handler 2: " + args[0] + " " + args[1]);
	}
	
	func handler3(args)
	{
		println("handler 3: " + args[0] + " " + args[1]);
	}
	
	func handler4(args)
	{
		println("handler 4: " + args[0] + " " + args[1]);
	}
	hand = new Event(handler1, handler2);
	
	hand += handler3;
	hand += handler4;
	
	hand("abc", "def");
	
	hand -= handler1;
	hand -= handler2;
	hand -= handler3;
	
	hand("abc", "def");
	
	println();
    println("End of event tests");
    println();
}

func arrayTests()
{
	println("Array tests");
	println();
	
	theArr = ["abc", "def", 123, 456, runtimecall("System.Math.PI")];	
	assert(theArr.toString() == "Array { abc, def, 123, 456, 3.14159265358979 }", "array to string");
	theArr2 = [];
	foreach(x in theArr)
	{
		theArr2[] = x;
	}	
	assert(theArr2.toString() == "Array { abc, def, 123, 456, 3.14159265358979 }", "array to string after foreach");

	theDict = ["abc" : 123, 456 : "ghi", "jkl" : 789];
	theDict[123] = "mno";
	theDict[] = 456; # if you use the [] operator with nothing inside, it appends at the end of the array
	assert(theDict[123] == "mno", "check dictionary value after setting with []");
	assert(theDict.toString() == "Dictionary { [abc] => 123, [456] => ghi, [jkl] => 789, [123] => mno, [4] => 456 }", "dictionary to string");
	
	foreach([key, value] in theDict) # by using the tuple syntax you can foreach the keys and values
	{
		assert(theDict[key] == value, "check key and value, foreach in a dictionary");
	}
	
	println();
	println("End of array tests");
	println();
}